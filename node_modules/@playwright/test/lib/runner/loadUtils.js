"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadAllTests = loadAllTests;
exports.loadGlobalHook = loadGlobalHook;
exports.loadReporter = loadReporter;
var _path = _interopRequireDefault(require("path"));
var _loaderHost = require("./loaderHost");
var _test = require("../common/test");
var _util = require("../util");
var _projectUtils = require("./projectUtils");
var _transform = require("../common/transform");
var _suiteUtils = require("../common/suiteUtils");
var _testGroups = require("./testGroups");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

async function loadAllTests(mode, config, projectsToIgnore, fileMatcher, errors, shouldFilterOnly) {
  const projects = (0, _projectUtils.filterProjects)(config.projects, config._internal.cliProjectFilter);
  let filesToRunByProject = new Map();
  let topLevelProjects;
  let dependencyProjects;
  // Collect files, categorize top level and dependency projects.
  {
    const fsCache = new Map();

    // First collect all files for the projects in the command line, don't apply any file filters.
    const allFilesForProject = new Map();
    for (const project of projects) {
      if (projectsToIgnore.has(project)) continue;
      const files = await (0, _projectUtils.collectFilesForProject)(project, fsCache);
      allFilesForProject.set(project, files);
    }

    // Filter files based on the file filters, eliminate the empty projects.
    for (const [project, files] of allFilesForProject) {
      const filteredFiles = files.filter(fileMatcher);
      if (filteredFiles.length) filesToRunByProject.set(project, filteredFiles);
    }
    const projectClosure = (0, _projectUtils.buildProjectsClosure)([...filesToRunByProject.keys()]);
    // Remove files for dependency projects, they'll be added back later.
    for (const project of projectClosure.filter(p => p._internal.type === 'dependency')) filesToRunByProject.delete(project);

    // Shard only the top-level projects.
    if (config.shard) filesToRunByProject = (0, _testGroups.filterForShard)(config.shard, filesToRunByProject);

    // Re-build the closure, project set might have changed.
    const filteredProjectClosure = (0, _projectUtils.buildProjectsClosure)([...filesToRunByProject.keys()]);
    topLevelProjects = filteredProjectClosure.filter(p => p._internal.type === 'top-level');
    dependencyProjects = filteredProjectClosure.filter(p => p._internal.type === 'dependency');
    topLevelProjects = topLevelProjects.filter(p => !projectsToIgnore.has(p));
    dependencyProjects = dependencyProjects.filter(p => !projectsToIgnore.has(p));

    // (Re-)add all files for dependent projects, disregard filters.
    for (const project of dependencyProjects) {
      const files = allFilesForProject.get(project) || (await (0, _projectUtils.collectFilesForProject)(project, fsCache));
      filesToRunByProject.set(project, files);
    }
  }

  // Load all test files and create a preprocessed root. Child suites are files there.
  const fileSuits = [];
  {
    const loaderHost = mode === 'out-of-process' ? new _loaderHost.OutOfProcessLoaderHost(config) : new _loaderHost.InProcessLoaderHost(config);
    const allTestFiles = new Set();
    for (const files of filesToRunByProject.values()) files.forEach(file => allTestFiles.add(file));
    for (const file of allTestFiles) {
      const fileSuite = await loaderHost.loadTestFile(file, errors);
      fileSuits.push(fileSuite);
    }
    await loaderHost.stop();
  }

  // Complain about duplicate titles.
  errors.push(...createDuplicateTitlesErrors(config, fileSuits));

  // Create root suites with clones for the projects.
  const rootSuite = new _test.Suite('', 'root');

  // Interpret cli parameters.
  const cliFileFilters = (0, _util.createFileFiltersFromArguments)(config._internal.cliArgs);
  const grepMatcher = config._internal.cliGrep ? (0, _util.createTitleMatcher)((0, _util.forceRegExp)(config._internal.cliGrep)) : () => true;
  const grepInvertMatcher = config._internal.cliGrepInvert ? (0, _util.createTitleMatcher)((0, _util.forceRegExp)(config._internal.cliGrepInvert)) : () => false;
  const cliTitleMatcher = title => !grepInvertMatcher(title) && grepMatcher(title);

  // First iterate leaf projects to focus only, then add all other projects.
  for (const project of topLevelProjects) {
    const projectSuite = await createProjectSuite(fileSuits, project, {
      cliFileFilters,
      cliTitleMatcher,
      testIdMatcher: config._internal.testIdMatcher
    }, filesToRunByProject.get(project));
    if (projectSuite) rootSuite._addSuite(projectSuite);
  }

  // Complain about only.
  if (config.forbidOnly) {
    const onlyTestsAndSuites = rootSuite._getOnlyItems();
    if (onlyTestsAndSuites.length > 0) errors.push(...createForbidOnlyErrors(onlyTestsAndSuites));
  }

  // Filter only for leaf projects.
  if (shouldFilterOnly) (0, _suiteUtils.filterOnly)(rootSuite);

  // Prepend the projects that are dependencies.
  for (const project of dependencyProjects) {
    const projectSuite = await createProjectSuite(fileSuits, project, {
      cliFileFilters: [],
      cliTitleMatcher: undefined
    }, filesToRunByProject.get(project));
    if (projectSuite) rootSuite._prependSuite(projectSuite);
  }
  return rootSuite;
}
async function createProjectSuite(fileSuits, project, options, files) {
  const fileSuitesMap = new Map();
  for (const fileSuite of fileSuits) fileSuitesMap.set(fileSuite._requireFile, fileSuite);
  const projectSuite = new _test.Suite(project.name, 'project');
  projectSuite._projectConfig = project;
  if (project._internal.fullyParallel) projectSuite._parallelMode = 'parallel';
  for (const file of files) {
    const fileSuite = fileSuitesMap.get(file);
    if (!fileSuite) continue;
    for (let repeatEachIndex = 0; repeatEachIndex < project.repeatEach; repeatEachIndex++) {
      const builtSuite = (0, _suiteUtils.buildFileSuiteForProject)(project, fileSuite, repeatEachIndex);
      projectSuite._addSuite(builtSuite);
    }
  }
  (0, _suiteUtils.filterByFocusedLine)(projectSuite, options.cliFileFilters);
  (0, _suiteUtils.filterByTestIds)(projectSuite, options.testIdMatcher);
  const grepMatcher = (0, _util.createTitleMatcher)(project.grep);
  const grepInvertMatcher = project.grepInvert ? (0, _util.createTitleMatcher)(project.grepInvert) : null;
  const titleMatcher = test => {
    const grepTitle = test.titlePath().join(' ');
    if (grepInvertMatcher !== null && grepInvertMatcher !== void 0 && grepInvertMatcher(grepTitle)) return false;
    return grepMatcher(grepTitle) && (!options.cliTitleMatcher || options.cliTitleMatcher(grepTitle));
  };
  if ((0, _suiteUtils.filterTestsRemoveEmptySuites)(projectSuite, titleMatcher)) return projectSuite;
  return null;
}
function createForbidOnlyErrors(onlyTestsAndSuites) {
  const errors = [];
  for (const testOrSuite of onlyTestsAndSuites) {
    // Skip root and file.
    const title = testOrSuite.titlePath().slice(2).join(' ');
    const error = {
      message: `Error: focused item found in the --forbid-only mode: "${title}"`,
      location: testOrSuite.location
    };
    errors.push(error);
  }
  return errors;
}
function createDuplicateTitlesErrors(config, fileSuites) {
  const errors = [];
  for (const fileSuite of fileSuites) {
    const testsByFullTitle = new Map();
    for (const test of fileSuite.allTests()) {
      const fullTitle = test.titlePath().slice(1).join(' â€º ');
      const existingTest = testsByFullTitle.get(fullTitle);
      if (existingTest) {
        const error = {
          message: `Error: duplicate test title "${fullTitle}", first declared in ${buildItemLocation(config.rootDir, existingTest)}`,
          location: test.location
        };
        errors.push(error);
      }
      testsByFullTitle.set(fullTitle, test);
    }
  }
  return errors;
}
function buildItemLocation(rootDir, testOrSuite) {
  if (!testOrSuite.location) return '';
  return `${_path.default.relative(rootDir, testOrSuite.location.file)}:${testOrSuite.location.line}`;
}
async function requireOrImportDefaultFunction(file, expectConstructor) {
  let func = await (0, _transform.requireOrImport)(file);
  if (func && typeof func === 'object' && 'default' in func) func = func['default'];
  if (typeof func !== 'function') throw (0, _util.errorWithFile)(file, `file must export a single ${expectConstructor ? 'class' : 'function'}.`);
  return func;
}
function loadGlobalHook(config, file) {
  return requireOrImportDefaultFunction(_path.default.resolve(config.rootDir, file), false);
}
function loadReporter(config, file) {
  return requireOrImportDefaultFunction(_path.default.resolve(config.rootDir, file), true);
}